---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - .env.example
  - apps/web/package.json
  - apps/web/tsconfig.json
  - apps/web/next.config.ts
  - apps/web/src/lib/db/schema.ts
  - apps/web/src/lib/db/index.ts
  - apps/web/drizzle.config.ts
  - apps/web/Dockerfile
  - apps/api/pyproject.toml
  - apps/api/src/main.py
  - apps/api/src/db/models.py
  - apps/api/src/db/session.py
  - apps/api/Dockerfile
autonomous: true

must_haves:
  truths:
    - "docker compose up starts PostgreSQL, Redis, Vexa services, Next.js web app, and FastAPI api service without errors"
    - "Drizzle schema push creates all TargetDialer extension tables (td_users, td_meetings, td_transcript_segments, td_calendar_subscriptions) with correct columns and indexes"
    - "GIN index on td_transcript_segments.text exists before any data is inserted"
    - "FastAPI /health endpoint returns 200 and can connect to PostgreSQL"
    - "Next.js dev server starts and renders a placeholder page"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Full service orchestration extending Vexa"
      contains: "services"
    - path: "apps/web/src/lib/db/schema.ts"
      provides: "All TargetDialer extension table definitions"
      contains: "tdTranscriptSegments"
    - path: "apps/web/src/lib/db/index.ts"
      provides: "Drizzle client singleton"
      exports: ["db"]
    - path: "apps/api/src/main.py"
      provides: "FastAPI application entry point"
      contains: "FastAPI"
    - path: "apps/api/src/db/session.py"
      provides: "Async DB session factory for Python service"
      contains: "async"
  key_links:
    - from: "docker-compose.yml"
      to: "PostgreSQL"
      via: "service definition with health check"
      pattern: "postgres.*healthcheck"
    - from: "apps/web/src/lib/db/index.ts"
      to: "PostgreSQL"
      via: "postgres.js connection string from DATABASE_URL"
      pattern: "postgres.*DATABASE_URL"
    - from: "apps/api/src/db/session.py"
      to: "PostgreSQL"
      via: "asyncpg connection pool"
      pattern: "asyncpg|DATABASE_URL"
---

<objective>
Scaffold the two-service monorepo (Next.js 16 + Python FastAPI), configure Docker Compose to extend Vexa services, create the PostgreSQL schema with all TargetDialer extension tables and GIN indexes, and verify both services start and connect to the database.

Purpose: Everything in Phase 1 depends on this scaffold — auth needs the schema, calendar needs the project structure, Vexa integration needs the FastAPI service. Nothing can proceed without a working two-service stack with a migrated database.

Output: A running docker-compose stack with Next.js, FastAPI, PostgreSQL, and Redis — all tables created, all indexes in place, both services responding to health checks.
</objective>

<execution_context>
@C:\Users\Gustavo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Gustavo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create monorepo structure, Docker Compose, and environment config</name>
  <files>
    docker-compose.yml
    .env.example
    apps/web/package.json
    apps/web/tsconfig.json
    apps/web/next.config.ts
    apps/web/Dockerfile
    apps/api/pyproject.toml
    apps/api/Dockerfile
    apps/api/src/__init__.py
  </files>
  <action>
    Create the monorepo directory structure:
    ```
    meetrec/
    ├── apps/
    │   ├── web/          # Next.js 16
    │   └── api/          # Python FastAPI
    ├── docker-compose.yml
    └── .env.example
    ```

    **docker-compose.yml:**
    - Define services: `postgres` (PostgreSQL 16 with healthcheck), `redis` (Redis 7), `web` (Next.js, builds from apps/web/Dockerfile), `api` (FastAPI, builds from apps/api/Dockerfile)
    - Do NOT include Vexa services yet — Vexa's own docker-compose will be extended later when we have access to their repo. For now, stub a comment noting where Vexa services will be added.
    - PostgreSQL: port 5432, volume for data persistence, healthcheck using `pg_isready`
    - Redis: port 6379, healthcheck using `redis-cli ping`
    - Web service: port 3000, depends_on postgres (healthy) and redis (healthy), mount apps/web as volume for dev, env from .env
    - API service: port 8000, depends_on postgres (healthy) and redis (healthy), mount apps/api as volume for dev, env from .env
    - All services on a shared `meetrec` network

    **.env.example:**
    ```
    # Database
    DATABASE_URL=postgresql://meetrec:meetrec@postgres:5432/meetrec
    POSTGRES_USER=meetrec
    POSTGRES_PASSWORD=meetrec
    POSTGRES_DB=meetrec

    # Redis
    REDIS_URL=redis://redis:6379

    # Auth (Phase 01-02)
    AUTH_SECRET=generate-a-secret-here
    GOOGLE_CLIENT_ID=
    GOOGLE_CLIENT_SECRET=

    # App
    PUBLIC_URL=http://localhost:3000
    NEXTAUTH_URL=http://localhost:3000

    # Vexa (Phase 01-04)
    VEXA_API_URL=http://api-gateway:8056
    VEXA_API_KEY=
    VEXA_ADMIN_API_KEY=
    ```

    **apps/web/package.json:**
    - name: "@meetrec/web"
    - Initialize with Next.js 16 (`next@latest`), React 19, TypeScript
    - Add dependencies: `drizzle-orm`, `postgres` (postgres.js driver), `zod`
    - Add devDependencies: `drizzle-kit`, `typescript`, `@types/node`, `@types/react`
    - Scripts: `dev`, `build`, `start`, `db:push` (drizzle-kit push), `db:studio` (drizzle-kit studio)
    - Run `pnpm install` in apps/web after creating package.json

    **apps/web/tsconfig.json:**
    - Standard Next.js 16 tsconfig with path aliases: `@/*` maps to `./src/*`

    **apps/web/next.config.ts:**
    - Minimal config, enable standalone output for Docker

    **apps/web/Dockerfile:**
    - Multi-stage: deps stage (pnpm install --legacy-peer-deps), build stage (next build), runner stage (standalone output)
    - Use node:22-alpine base
    - For dev: use `pnpm dev` as CMD

    **apps/api/pyproject.toml:**
    - name: "meetrec-api"
    - Use uv for dependency management
    - Dependencies: fastapi, uvicorn[standard], httpx, arq, redis, sqlalchemy, asyncpg, psycopg2-binary, cryptography, pydantic, python-dotenv
    - Dev dependencies: ruff, pytest, pytest-asyncio
    - Run `uv sync` in apps/api after creating pyproject.toml

    **apps/api/Dockerfile:**
    - Use python:3.12-slim base
    - Install uv, copy pyproject.toml, run `uv sync`
    - For dev: CMD `uvicorn src.main:app --host 0.0.0.0 --port 8000 --reload`

    Create placeholder `apps/api/src/__init__.py` (empty file).
  </action>
  <verify>
    1. `ls apps/web/package.json apps/api/pyproject.toml docker-compose.yml .env.example` — all exist
    2. `cd apps/web && pnpm install --legacy-peer-deps` succeeds
    3. `cd apps/api && uv sync` succeeds
    4. `docker compose config` validates without errors
  </verify>
  <done>
    Monorepo structure exists with both service directories, Docker Compose validates, dependencies install successfully for both services.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Drizzle schema with all extension tables + GIN indexes, FastAPI with health check, verify database connectivity</name>
  <files>
    apps/web/src/lib/db/schema.ts
    apps/web/src/lib/db/index.ts
    apps/web/drizzle.config.ts
    apps/web/src/app/layout.tsx
    apps/web/src/app/page.tsx
    apps/api/src/main.py
    apps/api/src/db/models.py
    apps/api/src/db/session.py
  </files>
  <action>
    **apps/web/src/lib/db/schema.ts:**
    Define ALL TargetDialer extension tables exactly as specified in the research doc (Pattern 2):
    - `userRoleEnum` — pgEnum with values ["admin", "member"]
    - `tdUsers` — id (uuid PK), authUserId (text, unique, not null), vexaUserId (text, nullable), role (userRoleEnum, default "member"), googleRefreshToken (text, nullable — encrypted at rest), createdAt (timestamp with timezone)
    - `tdCalendarSubscriptions` — id (uuid PK), userId (text, not null), googleChannelId (text, unique), resourceId (text), calendarId (text, not null), expiresAt (timestamp with tz, not null), renewedAt (timestamp with tz, nullable), createdAt (timestamp with tz)
    - `tdTranscriptSegments` — id (uuid PK), vexaMeetingId (text, not null), platform (text, not null), sessionUid (text, nullable — Vexa bug #96 workaround), speaker (text, nullable), text (text, not null), startTime (text, nullable), endTime (text, nullable), absoluteStartTime (timestamp with tz), absoluteEndTime (timestamp with tz), language (text, default "en"), createdAt (timestamp with tz). Indexes: GIN on `to_tsvector('english', text)`, btree on vexaMeetingId, btree on speaker, btree on absoluteStartTime
    - `tdMeetings` — id (uuid PK), vexaMeetingId (text, not null, unique), platform (text, not null), userId (text, not null), calendarEventId (text, nullable), meetingTitle (text, nullable), scheduledStartAt (timestamp with tz), botJoinedAt (timestamp with tz), firstSegmentAt (timestamp with tz), meetingEndedAt (timestamp with tz), botStatus (text, default "requested"), segmentCount (text, default "0"), createdAt (timestamp with tz)

    Use exact Drizzle syntax from research: `pgTable`, `pgEnum`, `uuid().primaryKey().defaultRandom()`, `index().using('gin', sql\`to_tsvector(...)\`)`.

    **apps/web/src/lib/db/index.ts:**
    Create Drizzle client singleton using `postgres` (postgres.js) driver:
    ```typescript
    import { drizzle } from "drizzle-orm/postgres-js"
    import postgres from "postgres"
    import * as schema from "./schema"

    const connectionString = process.env.DATABASE_URL!
    const client = postgres(connectionString)
    export const db = drizzle(client, { schema })
    ```

    **apps/web/drizzle.config.ts:**
    ```typescript
    import { defineConfig } from "drizzle-kit"

    export default defineConfig({
      schema: "./src/lib/db/schema.ts",
      out: "./drizzle",
      dialect: "postgresql",
      dbCredentials: {
        url: process.env.DATABASE_URL!,
      },
    })
    ```

    **apps/web/src/app/layout.tsx + page.tsx:**
    Minimal Next.js app with a root layout (html, body, children) and a home page that says "TargetDialer — Meeting Intelligence" as placeholder. Use Tailwind CSS via `@tailwindcss/postcss` if Next.js 16 includes it by default, otherwise skip styling for now.

    **apps/api/src/main.py:**
    Create FastAPI app with:
    - GET `/health` endpoint that returns `{"status": "ok", "service": "meetrec-api"}` and tests DB connectivity (run a simple `SELECT 1` via asyncpg)
    - CORS middleware allowing `http://localhost:3000`
    - Lifespan handler that creates and closes the asyncpg connection pool

    **apps/api/src/db/session.py:**
    Create async DB session factory using asyncpg:
    ```python
    import asyncpg
    import os

    async def create_pool():
        return await asyncpg.create_pool(os.environ["DATABASE_URL"])
    ```

    **apps/api/src/db/models.py:**
    SQLAlchemy model stubs (for reference — the Python service reads/writes the same tables Drizzle creates):
    - TdMeeting model mapping to td_meetings table
    - TdTranscriptSegment model mapping to td_transcript_segments table
    Keep these as reference models — Drizzle is the source of truth for schema.

    **After creating all files, run schema push:**
    1. Start PostgreSQL via `docker compose up -d postgres`
    2. Copy .env.example to .env (with localhost:5432 for local Drizzle push)
    3. Run `cd apps/web && DATABASE_URL=postgresql://meetrec:meetrec@localhost:5432/meetrec pnpm db:push`
    4. Verify tables exist: `docker compose exec postgres psql -U meetrec -c "\dt td_*"`
    5. Verify GIN index: `docker compose exec postgres psql -U meetrec -c "\di idx_transcript_fts"`
  </action>
  <verify>
    1. `docker compose up -d postgres redis` — starts without errors
    2. `cd apps/web && DATABASE_URL=postgresql://meetrec:meetrec@localhost:5432/meetrec pnpm db:push` — creates all tables
    3. `docker compose exec postgres psql -U meetrec -c "\dt td_*"` — shows td_users, td_meetings, td_transcript_segments, td_calendar_subscriptions
    4. `docker compose exec postgres psql -U meetrec -c "\di idx_transcript_fts"` — shows GIN index
    5. `docker compose up -d` — all services start (web on 3000, api on 8000)
    6. `curl http://localhost:3000` — returns HTML (Next.js placeholder page)
    7. `curl http://localhost:8000/health` — returns `{"status": "ok", "service": "meetrec-api"}`
  </verify>
  <done>
    All four TD extension tables created with correct columns and types. GIN index on transcript text confirmed. Both Next.js and FastAPI services running and responding. Docker Compose stack fully operational with PostgreSQL and Redis.
  </done>
</task>

</tasks>

<verification>
1. `docker compose ps` shows all services running (postgres, redis, web, api)
2. Database has all four td_* tables with correct column types
3. GIN index `idx_transcript_fts` exists on td_transcript_segments
4. `curl http://localhost:3000` returns Next.js page
5. `curl http://localhost:8000/health` returns 200 with OK status
6. Both services can connect to PostgreSQL (web via drizzle-kit push, api via health check)
</verification>

<success_criteria>
- Two-service monorepo structure exists at apps/web and apps/api
- Docker Compose starts all services without manual intervention
- PostgreSQL schema contains td_users, td_meetings, td_transcript_segments, td_calendar_subscriptions
- GIN full-text search index exists on transcript text column
- Both web and api services respond to HTTP requests
- .env.example documents all required environment variables
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
