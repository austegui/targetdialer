---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/web/package.json
  - apps/web/src/auth.ts
  - apps/web/src/proxy.ts
  - apps/web/src/app/api/auth/[...nextauth]/route.ts
  - apps/web/src/app/(auth)/login/page.tsx
  - apps/web/src/app/(dashboard)/layout.tsx
  - apps/web/src/app/(dashboard)/meetings/page.tsx
  - apps/web/src/lib/db/schema.ts
autonomous: false
user_setup:
  - service: google-oauth
    why: "Google OAuth for team authentication and Calendar API access"
    env_vars:
      - name: GOOGLE_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID"
      - name: GOOGLE_CLIENT_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID"
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID (Web application type)"
        location: "Google Cloud Console -> APIs & Services -> Credentials"
      - task: "Add authorized redirect URI: http://localhost:3000/api/auth/callback/google"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth Client"
      - task: "Enable Google Calendar API"
        location: "Google Cloud Console -> APIs & Services -> Library -> Google Calendar API"

must_haves:
  truths:
    - "User can click 'Sign in with Google' and complete the OAuth flow to reach the dashboard"
    - "After sign-in, user session persists across page refreshes (database-backed session)"
    - "Google refresh_token is stored in the Auth.js accounts table after sign-in (prompt: consent forces this)"
    - "Unauthenticated users are redirected to the login page when visiting any dashboard route"
    - "Admin users see a 'Team Settings' link in the dashboard; member users do not"
  artifacts:
    - path: "apps/web/src/auth.ts"
      provides: "Auth.js v5 config with Google provider, Drizzle adapter, Calendar scope"
      contains: "calendar.readonly"
    - path: "apps/web/src/proxy.ts"
      provides: "Next.js 16 proxy (replaces middleware.ts) for session-based route protection"
      contains: "auth as proxy"
    - path: "apps/web/src/app/api/auth/[...nextauth]/route.ts"
      provides: "Auth.js API route handler"
      exports: ["GET", "POST"]
    - path: "apps/web/src/app/(auth)/login/page.tsx"
      provides: "Login page with Google sign-in button"
      min_lines: 15
    - path: "apps/web/src/app/(dashboard)/meetings/page.tsx"
      provides: "Protected meetings page showing user info"
      min_lines: 15
  key_links:
    - from: "apps/web/src/auth.ts"
      to: "apps/web/src/lib/db/index.ts"
      via: "DrizzleAdapter(db) for session persistence"
      pattern: "DrizzleAdapter.*db"
    - from: "apps/web/src/proxy.ts"
      to: "apps/web/src/auth.ts"
      via: "export { auth as proxy }"
      pattern: "auth as proxy"
    - from: "apps/web/src/auth.ts"
      to: "Google OAuth"
      via: "Google provider with calendar.readonly scope and prompt: consent"
      pattern: "prompt.*consent"
---

<objective>
Implement Google OAuth authentication using Auth.js v5 with database-backed sessions, Calendar API scope, and role-based access control (admin vs member).

Purpose: Authentication is the gateway to everything else. Calendar Watcher (Plan 03) needs the stored Google refresh_token to call the Calendar API on behalf of users. Role-based access enables admin-only team settings.

Output: Working Google sign-in flow, protected dashboard routes, role column on td_users, refresh tokens persisted in database.
</objective>

<execution_context>
@C:\Users\Gustavo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Gustavo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Auth.js v5, configure Google OAuth with Calendar scope, create protected routes</name>
  <files>
    apps/web/package.json
    apps/web/src/auth.ts
    apps/web/src/proxy.ts
    apps/web/src/app/api/auth/[...nextauth]/route.ts
    apps/web/src/app/(auth)/login/page.tsx
    apps/web/src/app/(dashboard)/layout.tsx
    apps/web/src/app/(dashboard)/meetings/page.tsx
    apps/web/src/lib/db/schema.ts
  </files>
  <action>
    **Install Auth.js v5 packages (MUST use --legacy-peer-deps due to Next.js 16 peer conflict):**
    ```bash
    cd apps/web && pnpm add next-auth@beta @auth/drizzle-adapter --legacy-peer-deps
    ```

    **apps/web/src/auth.ts:**
    Configure Auth.js v5 exactly as documented in the research:
    - Use `DrizzleAdapter(db)` for database-backed sessions (import db from `@/lib/db`)
    - Session strategy: `"database"` (NOT jwt — refresh tokens must be persisted)
    - Google provider with these EXACT authorization params:
      - scope: `"openid email profile https://www.googleapis.com/auth/calendar.readonly"`
      - prompt: `"consent"` (MANDATORY — without this, refresh token is not returned on re-login)
      - access_type: `"offline"` (MANDATORY — enables refresh token)
      - response_type: `"code"`
    - Callbacks:
      - `session` callback: attach `user.id` and `user.role` (from td_users) to the session object
      - `signIn` callback: after first sign-in, create a td_users row if one doesn't exist for this auth user, with role "member" by default
    - Export: `{ handlers, auth, signIn, signOut }`
    - Environment variables used: `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`, `AUTH_SECRET`

    **IMPORTANT:** The DrizzleAdapter will auto-create Auth.js required tables (users, accounts, sessions, verification_tokens) on first use. Make sure the schema.ts also exports these Auth.js tables so Drizzle knows about them. Use `@auth/drizzle-adapter` built-in schema exports OR define them manually. Check the @auth/drizzle-adapter docs for the recommended approach — the adapter may handle this automatically via `drizzle-kit push`.

    **apps/web/src/proxy.ts (Next.js 16 — replaces middleware.ts):**
    ```typescript
    export { auth as proxy } from "@/auth"

    export const config = {
      matcher: ["/((?!api|_next/static|_next/image|favicon.ico|login).*)"],
    }
    ```
    This protects all routes except /api, static assets, and /login. Unauthenticated users hitting protected routes get redirected to the login page.

    **apps/web/src/app/api/auth/[...nextauth]/route.ts:**
    ```typescript
    import { handlers } from "@/auth"
    export const { GET, POST } = handlers
    ```

    **apps/web/src/app/(auth)/login/page.tsx:**
    Create a login page with:
    - "TargetDialer" heading
    - "Sign in with Google" button that calls `signIn("google")` from next-auth/react
    - Simple centered layout, no complex styling needed yet

    **apps/web/src/app/(dashboard)/layout.tsx:**
    Create a dashboard layout that:
    - Calls `auth()` to get the session server-side
    - If no session, redirect to /login
    - Displays a top nav with: user name, user email, role badge, sign out button
    - If user.role === "admin", show a "Team Settings" link
    - Renders children

    **apps/web/src/app/(dashboard)/meetings/page.tsx:**
    Create a meetings page (placeholder):
    - Shows "Meetings" heading
    - Shows "No meetings yet" placeholder
    - This is the landing page after login — redirect root "/" to "/meetings"

    **apps/web/src/lib/db/schema.ts (UPDATE):**
    Add Auth.js required tables to the existing schema. The `@auth/drizzle-adapter` expects specific tables. Either:
    1. Import and re-export the schema from `@auth/drizzle-adapter/drizzle` if available, OR
    2. Define `users`, `accounts`, `sessions`, `verificationTokens` tables per Auth.js Drizzle adapter docs

    The existing td_users table links to Auth.js users table via `authUserId` column.

    **Update .env (local):**
    - Set `AUTH_SECRET` to a generated random string (run `openssl rand -base64 32`)
    - User will need to provide GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET (see user_setup)

    **After implementation:**
    - Run `drizzle-kit push` again to add Auth.js tables to the database
    - Verify the auth route is accessible: `curl -I http://localhost:3000/api/auth/providers`
  </action>
  <verify>
    1. `pnpm ls next-auth @auth/drizzle-adapter` in apps/web — both installed
    2. `curl http://localhost:3000/api/auth/providers` returns JSON with "google" provider
    3. Auth.js tables exist in DB: `docker compose exec postgres psql -U meetrec -c "\dt" | grep -E "users|accounts|sessions"`
    4. `curl -I http://localhost:3000/meetings` — redirects to /login (302 or similar)
    5. TypeScript compiles: `cd apps/web && pnpm build` (or `npx tsc --noEmit`)
  </verify>
  <done>
    Auth.js v5 configured with Google provider and Calendar scope. Protected routes redirect to login. Auth.js tables created in database. Drizzle adapter persists sessions. Role-based td_users extension ready.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Google OAuth sign-in flow with Auth.js v5, database-backed sessions, Calendar API scope, and role-based dashboard access.
  </what-built>
  <how-to-verify>
    Prerequisites: You must have set GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET in your .env file (from Google Cloud Console).

    1. Run `docker compose up` to start all services
    2. Visit http://localhost:3000 — you should be redirected to /login
    3. Click "Sign in with Google" — Google consent screen should appear requesting:
       - Basic profile access (email, name)
       - Google Calendar read-only access
    4. Complete sign-in — you should land on the /meetings page
    5. Verify your name and email appear in the top nav
    6. Refresh the page — session should persist (still logged in, not redirected to login)
    7. Check the database for the refresh token:
       ```
       docker compose exec postgres psql -U meetrec -c "SELECT id, provider, access_token IS NOT NULL as has_access, refresh_token IS NOT NULL as has_refresh FROM accounts;"
       ```
       The `has_refresh` column should be `true`
    8. Check td_users was created:
       ```
       docker compose exec postgres psql -U meetrec -c "SELECT * FROM td_users;"
       ```
       Should show one row with role = "member"
  </how-to-verify>
  <resume-signal>Type "approved" if sign-in works and tokens are stored, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Full OAuth flow works: login page -> Google consent -> dashboard redirect
2. Session persists across page refreshes (database-backed, not just cookies)
3. Refresh token stored in accounts table (verified via SQL query)
4. td_users row created on first sign-in with role "member"
5. Unauthenticated access to /meetings redirects to /login
6. proxy.ts protects all dashboard routes
</verification>

<success_criteria>
- AUTH-01 satisfied: User can sign in with Google OAuth (Google Workspace accounts)
- AUTH-02 partially satisfied: Role column exists in td_users; admin sees Team Settings link, member does not (full admin page is a later concern)
- Google refresh_token is persisted in the database for Calendar Watcher (Plan 03)
- Calendar API scope is included in the OAuth consent
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
