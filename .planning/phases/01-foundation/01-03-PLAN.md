---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - apps/web/package.json
  - apps/web/src/lib/calendar/watcher.ts
  - apps/web/src/lib/calendar/renewal.ts
  - apps/web/src/lib/calendar/token.ts
  - apps/web/src/app/api/calendar/webhook/route.ts
  - apps/web/src/app/api/calendar/register/route.ts
  - apps/web/src/app/api/cron/calendar-renewal/route.ts
  - apps/web/src/app/(dashboard)/settings/page.tsx
autonomous: true

must_haves:
  truths:
    - "When a Google Calendar event with a Google Meet link is created, the system detects it within minutes via webhook push notification"
    - "The system stores a syncToken and uses it to fetch only changed events (delta sync), not the full calendar"
    - "A cron job runs every 6 hours and renews any Calendar webhook channel expiring within 48 hours"
    - "If the webhook channel is down, an hourly fallback poll catches meetings that would have been missed"
    - "Detected meetings with Google Meet URLs are logged to td_meetings with status 'requested' — ready for bot dispatch"
    - "User can configure which calendars to watch (CAL-04)"
  artifacts:
    - path: "apps/web/src/lib/calendar/watcher.ts"
      provides: "Calendar watch registration and event detection logic"
      contains: "events.watch"
    - path: "apps/web/src/lib/calendar/renewal.ts"
      provides: "Channel renewal logic — finds expiring channels and re-registers"
      contains: "renewExpiringChannels"
    - path: "apps/web/src/lib/calendar/token.ts"
      provides: "Google OAuth token retrieval from Auth.js accounts table + refresh logic"
      contains: "getAccessTokenForUser"
    - path: "apps/web/src/app/api/calendar/webhook/route.ts"
      provides: "POST handler for Google Calendar push notifications"
      contains: "X-Goog-Resource-State"
    - path: "apps/web/src/app/api/cron/calendar-renewal/route.ts"
      provides: "Cron endpoint that triggers channel renewal"
      contains: "renewExpiringChannels"
  key_links:
    - from: "apps/web/src/app/api/calendar/webhook/route.ts"
      to: "apps/web/src/lib/calendar/watcher.ts"
      via: "detectAndDispatchMeetings function call"
      pattern: "detectAndDispatchMeetings"
    - from: "apps/web/src/lib/calendar/watcher.ts"
      to: "Google Calendar API"
      via: "events.watch for registration, events.list with syncToken for delta"
      pattern: "events\\.watch|events\\.list"
    - from: "apps/web/src/lib/calendar/token.ts"
      to: "Auth.js accounts table"
      via: "Query accounts table for Google access_token, refresh if expired"
      pattern: "accounts.*google"
    - from: "apps/web/src/lib/calendar/renewal.ts"
      to: "apps/web/src/lib/db/schema.ts"
      via: "Query td_calendar_subscriptions for expiring channels"
      pattern: "tdCalendarSubscriptions.*expiresAt"
---

<objective>
Build the Calendar Watcher: Google Calendar webhook registration, event detection (finding new meetings with Google Meet links), webhook renewal cron, fallback polling, and meeting configuration. When a meeting is detected, create a td_meetings row with status "requested" — ready for Vexa bot dispatch in Plan 04.

Purpose: This is the trigger mechanism for the entire system. Without the Calendar Watcher detecting meetings, no bots are dispatched and no transcripts are captured. The renewal cron and fallback poll are critical reliability mechanisms — without them, the system silently stops detecting meetings after 7 days.

Output: Automatic meeting detection via Google Calendar webhooks, reliable channel renewal, detected meetings stored in td_meetings.
</objective>

<execution_context>
@C:\Users\Gustavo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Gustavo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Google Calendar token retrieval, webhook registration, and event detection</name>
  <files>
    apps/web/package.json
    apps/web/src/lib/calendar/token.ts
    apps/web/src/lib/calendar/watcher.ts
    apps/web/src/app/api/calendar/webhook/route.ts
    apps/web/src/app/api/calendar/register/route.ts
  </files>
  <action>
    **Install Google Calendar API client:**
    ```bash
    cd apps/web && pnpm add googleapis --legacy-peer-deps
    ```

    **apps/web/src/lib/calendar/token.ts:**
    Create a function `getAccessTokenForUser(userId: string)` that:
    1. Queries the Auth.js `accounts` table for the Google account linked to this user
    2. Reads `access_token`, `refresh_token`, `expires_at` from the row
    3. If `expires_at` is in the future (with 5-minute buffer), return the existing `access_token`
    4. If expired, use the `refresh_token` to get a new access token via Google's token endpoint:
       ```
       POST https://oauth2.googleapis.com/token
       grant_type=refresh_token&refresh_token=XXX&client_id=XXX&client_secret=XXX
       ```
    5. Update the `accounts` table with the new `access_token` and `expires_at`
    6. Return the fresh access token
    7. If no refresh_token exists, throw an error (user needs to re-authenticate with prompt: consent)

    This function is critical — it's used by BOTH the webhook handler and the renewal cron to make Calendar API calls on behalf of users.

    **apps/web/src/lib/calendar/watcher.ts:**
    Create these functions:

    `registerCalendarWatch(userId, accessToken, calendarId = "primary")`:
    - Call `google.calendar.events.watch()` with:
      - channelId: crypto.randomUUID()
      - type: "web_hook"
      - address: `${process.env.PUBLIC_URL}/api/calendar/webhook`
      - expiration: 7 days from now (in milliseconds)
    - Store the channel in td_calendar_subscriptions (channelId, resourceId, expiresAt)
    - Also do an initial `events.list()` call to get the first `nextSyncToken` and store it (add a `syncToken` column to td_calendar_subscriptions if not already there, or store in a separate key-value — simplest is to add the column)

    `detectAndDispatchMeetings(channelId)`:
    - Look up the channel in td_calendar_subscriptions to find the userId and calendarId
    - Get a fresh access token via `getAccessTokenForUser(userId)`
    - Call `calendar.events.list({ calendarId, syncToken })` to get changed events
    - For each event that has `conferenceData.entryPoints` with type "video" and a Google Meet URI:
      - Extract the meeting code from the URI: `url.pathname.split('/').pop()?.split('?')[0]`
      - Check if a td_meetings row already exists for this meeting code (avoid duplicates)
      - If new: INSERT into td_meetings with vexaMeetingId = meeting code, platform = "google_meet", userId, calendarEventId = event.id, meetingTitle = event.summary, scheduledStartAt = event.start.dateTime, botStatus = "requested"
    - Update the stored syncToken with the `nextSyncToken` from the response
    - Log: "Detected N new meetings from calendar sync"

    NOTE on syncToken: The first time you register a watch, you need to do a full `events.list()` to get the initial syncToken. Store this syncToken so subsequent webhook notifications can use delta sync.

    **apps/web/src/app/api/calendar/webhook/route.ts:**
    POST handler that receives Google Calendar push notifications:
    - Read headers: `X-Goog-Resource-State`, `X-Goog-Channel-ID`, `X-Goog-Resource-ID`
    - If `resourceState === "sync"`: return 200 (initial handshake, do nothing)
    - If `resourceState === "exists"`: call `detectAndDispatchMeetings(channelId)`
    - Always return 200 (Google retries on non-200 and may disable the channel)
    - Wrap in try/catch — never throw from this handler

    IMPORTANT: Google sends HEADERS, not a body. The body is empty. All signal is in the headers.

    **apps/web/src/app/api/calendar/register/route.ts:**
    POST endpoint (auth-protected) that registers a calendar watch for the current user:
    - Get session via `auth()`
    - Get access token via `getAccessTokenForUser(session.user.id)`
    - Call `registerCalendarWatch(session.user.id, accessToken)`
    - Return success response

    **Schema update (if needed):**
    If td_calendar_subscriptions doesn't have a `syncToken` column, add it:
    ```typescript
    syncToken: text("sync_token"),
    ```
    Then run `drizzle-kit push` to apply.
  </action>
  <verify>
    1. `pnpm ls googleapis` in apps/web — installed
    2. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
    3. Calendar webhook endpoint exists: `curl -X POST http://localhost:3000/api/calendar/webhook -H "X-Goog-Resource-State: sync" -H "X-Goog-Channel-ID: test"` — returns 200
    4. Calendar register endpoint exists (will fail without auth, but should return 401 not 500): `curl -X POST http://localhost:3000/api/calendar/register` — returns auth error, not server error
    5. Token refresh function handles missing refresh token gracefully (throws typed error)
  </verify>
  <done>
    Calendar watch registration creates channels in Google and stores them in td_calendar_subscriptions. Webhook handler receives Google push notifications and detects new meetings with Meet links. Detected meetings are stored in td_meetings with status "requested". Token retrieval and refresh from Auth.js accounts table works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Webhook renewal cron, fallback hourly poll, and meeting configuration UI</name>
  <files>
    apps/web/src/lib/calendar/renewal.ts
    apps/web/src/app/api/cron/calendar-renewal/route.ts
    apps/web/src/app/(dashboard)/settings/page.tsx
    apps/web/src/lib/db/schema.ts
  </files>
  <action>
    **apps/web/src/lib/calendar/renewal.ts:**
    Create `renewExpiringChannels()`:
    - Query td_calendar_subscriptions for channels where `expiresAt < NOW() + 48 hours`
    - For each expiring channel:
      1. Get fresh access token via `getAccessTokenForUser(channel.userId)`
      2. Stop the old channel: `calendar.channels.stop({ id: channel.googleChannelId, resourceId: channel.resourceId })`
      3. Re-register: call `registerCalendarWatch(channel.userId, accessToken, channel.calendarId)`
      4. Delete the old channel row from td_calendar_subscriptions
      5. Log: "Renewed calendar channel for user {userId}, new expiry: {date}"
    - If any renewal fails, log the error but continue with other channels (don't let one failure block all renewals)
    - Return count of renewed channels

    Create `fallbackPollAllUsers()`:
    - Query all users who have at least one td_calendar_subscriptions row
    - For each user, call `detectAndDispatchMeetings` with their most recent channel
    - This is the safety net — catches any events missed during a channel gap
    - Log: "Fallback poll completed for N users"

    **apps/web/src/app/api/cron/calendar-renewal/route.ts:**
    GET endpoint (protected by a cron secret header) that:
    1. Calls `renewExpiringChannels()` — renew any channels expiring within 48h
    2. Calls `fallbackPollAllUsers()` — catch anything missed
    3. Returns JSON with counts: `{ renewed: N, polled: M }`
    4. Protection: check `Authorization: Bearer ${process.env.CRON_SECRET}` header. Reject if missing/wrong.

    This endpoint should be called every 6 hours. For self-hosted deployment, use `node-cron` in a separate script or trigger it via Docker healthcheck/cron. For now, just create the endpoint — the actual scheduling will use `cron` package.

    Add a simple cron scheduler in the API service or as a startup script:
    ```typescript
    // In apps/web/src/lib/calendar/cron.ts
    import { CronJob } from "cron"
    import { renewExpiringChannels, fallbackPollAllUsers } from "./renewal"

    // Run every 6 hours for renewal
    new CronJob("0 */6 * * *", async () => {
      await renewExpiringChannels()
    }).start()

    // Run every hour for fallback poll
    new CronJob("0 * * * *", async () => {
      await fallbackPollAllUsers()
    }).start()
    ```

    Import this in the Next.js instrumentation file (`apps/web/src/instrumentation.ts`) so cron jobs start when the server starts:
    ```typescript
    export async function register() {
      if (process.env.NEXT_RUNTIME === "nodejs") {
        await import("./lib/calendar/cron")
      }
    }
    ```

    **apps/web/src/app/(dashboard)/settings/page.tsx:**
    Create a settings page (admin-only, but for now accessible to all to test) with:
    - "Calendar Settings" section
    - Button: "Connect Calendar" — calls POST /api/calendar/register
    - Display list of active calendar subscriptions (from td_calendar_subscriptions): calendarId, expiresAt, status
    - For CAL-04 (meeting auto-join configuration): Add a simple form to configure which meetings to auto-join. For MVP, offer three options stored in td_users or a new td_user_settings table:
      1. "All meetings with Google Meet links" (default)
      2. "Only meetings matching keywords" (text input for comma-separated keywords that match event summary)
      3. "Disabled" (opt out)
    - Store the preference. The `detectAndDispatchMeetings` function should check this preference before creating td_meetings rows.

    **Schema update if needed for meeting preferences:**
    Add to td_users or create td_user_settings:
    ```typescript
    calendarAutoJoin: text("calendar_auto_join").default("all"), // "all" | "keywords" | "disabled"
    calendarKeywords: text("calendar_keywords"), // comma-separated keywords, nullable
    ```
    Run `drizzle-kit push` after schema changes.
  </action>
  <verify>
    1. `curl -H "Authorization: Bearer test-cron-secret" http://localhost:3000/api/cron/calendar-renewal` — returns JSON with renewed/polled counts (0 if no channels exist)
    2. `curl http://localhost:3000/api/cron/calendar-renewal` (no auth) — returns 401
    3. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
    4. Settings page loads at /settings (when authenticated)
    5. Schema pushed: `docker compose exec postgres psql -U meetrec -c "\d td_users"` shows calendar_auto_join column (or td_user_settings table exists)
    6. Renewal logic handles empty channel list gracefully (returns 0, no errors)
  </verify>
  <done>
    Webhook renewal cron renews expiring channels within 48h. Fallback hourly poll catches missed events. Calendar renewal endpoint is protected by cron secret. Settings page lets user connect calendar and configure auto-join preferences. CAL-03 (renewal) and CAL-04 (configuration) requirements are satisfied.
  </done>
</task>

</tasks>

<verification>
1. Calendar webhook registration creates a channel in Google Calendar API and stores it in td_calendar_subscriptions
2. Google push notifications are received at /api/calendar/webhook and trigger event detection
3. New meetings with Google Meet links create td_meetings rows with status "requested"
4. Renewal cron finds and renews expiring channels
5. Fallback poll catches events when webhook is down
6. Meeting auto-join preferences are configurable per user
7. Token refresh works when access token expires
</verification>

<success_criteria>
- CAL-01 satisfied: System watches Google Calendar for upcoming meetings with Google Meet links
- CAL-02 partially satisfied: Detected meetings stored as "requested" (bot dispatch is Plan 04)
- CAL-03 satisfied: Background job renews Calendar webhook channels before 7-day expiry
- CAL-04 satisfied: User can configure which meetings to auto-join
- Roadmap success criteria #2 met: System detects new Google Meet events within minutes
- Roadmap success criteria #3 met: Renewal job runs, channels re-registered before lapse
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
